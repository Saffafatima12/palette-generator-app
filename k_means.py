# -*- coding: utf-8 -*-
"""K_means.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KDA9f7tFnH10e0IGKoMAVaTRvPguoIzH
"""

## Importing all the necessary libraries ##

from math import sqrt
import random
try:
  import Image
except ImportError:
  from PIL import Image

def get_points(image_path):  
  img = Image.open(image_path)
  img.thumbnail((200, 400))
  img = img.convert("RGB")
  w, h = img.size
  
  points = []
  for count, color in img.getcolors(w * h):  # getcolors() returns the (number of pixels of a certain color, (r,g,b) of that color) // w*h argument is for the max number of colors in an img
    for _ in range(count): # _ basically says do nothing with the counter// for the number of pixels of one color
      points.append(Point(color))
    
  return points  ## points is a list of rgb values [(r,g,b), (r,g,b)...]

## function for getting euclidean distance

def euclidean(p, q):  # takes two points as the input argument
  n_dim = len(p.coordinates)  # coordinate attribute of the point class actually is just the rgb value of the point
  return sqrt(sum([
      (p.coordinates[i] - q.coordinates[i]) ** 2 for i in range(n_dim)      ## this calc basically calculates the diff btw rgb vals of two points
  ]))

## defining a point class ##

class Point:
  
  def __init__(self, coordinates):
    self.coordinates = coordinates

## define the cluster class ##

class Cluster:
  
  def __init__(self, center, points):
    self.center = center
    self.points = points

## define the KMeans class ##


class KMeans:
  
  
  ### 1. initializer for Kmeans class ###
  
  def __init__(self, n_clusters, min_diff = 1):  # put min_diff to 1 by default
    self.n_clusters = n_clusters
    self.min_diff = min_diff


  ### 2. this function returns average r,g,b value for an image ###  
  
  def calculate_center(self, points):    
    n_dim = len(points[0].coordinates)   # this will be a Point class and attribute coordinates is (r,g,b) 
    vals = [0.0 for i in range(n_dim)]   # 3 0s 
    for p in points:                     # for all pixels in an image
      for i in range(n_dim):             
        vals[i] += p.coordinates[i]      # [sum of r, sum of g, sum of b]
    coords = [(v / len(points)) for v in vals]  # [avg r, avg g, avg b]
    return Point(coords)  # make the list into a point with coordinates as the average r,g,b in an image
  
  
  ### 3. this function assigns points to clusters and returns a list of points arranged in clusters ### 
  
  def assign_points(self, clusters, points):
    plists = [[] for i in range(self.n_clusters)]  # p for point

    for p in points:                     # for each point in image (find the distance between that point and the center of a cluster)
      smallest_distance = float('inf')   # gives the largest possible value for comparison 

      for i in range(self.n_clusters):   # for each cluster
        distance = euclidean(p, clusters[i].center)  
        if distance < smallest_distance:
          smallest_distance = distance
          idx = i

      plists[idx].append(p)    # plists = [[p1,p4,p5], [p2,p3], [p6,p7..]..] // the point gets appended to the list at the index which corresponds to the cluster nummber with which the point has the smallest distance
    
    return plists
    
  def fit(self, points):
    clusters = [Cluster(center=p, points=[p]) for p in random.sample(points, self.n_clusters)] ## [cluster obj, cluster obj..] number of item in list = no. of clusters // each cluster gets assigned a center point p and a list points of the same point p from all the point in an image
    
    while True:

      plists = self.assign_points(clusters, points)  ## basically makes the point lists for each cluster within a plist

      diff = 0

      for i in range(self.n_clusters):  # for all the clusters
        if not plists[i]:               # if the cluster does not have any points?
          continue
        old = clusters[i]               # old is assigned a cluster from the cluster list
        center = self.calculate_center(plists[i])  # center is the center of all points in that cluster
        new = Cluster(center, plists[i])           # new is a cluster class with center and all the points, 
        clusters[i] = new                          # replace the randomly initialized cluster class in the clusters list with the new calculated cluster class
        diff = max(diff, euclidean(old.center, new.center)) # calculate the difference between the center points of the two clusters

      if diff < self.min_diff:
        break

    return clusters # returns the updated clusters list

from matplotlib.pyplot import imshow
import numpy as np

def rgb_to_hex(rgb):
  return '#%s' % ''.join(('%02x' % p for p in rgb))

def get_colors(filename, n_colors=3):
  #jpg = Image.open(filename)
  #imshow(np.asarray(jpg))
  points = get_points(filename)
  clusters = KMeans(n_clusters=n_colors).fit(points)
  clusters.sort(key=lambda c: len(c.points), reverse = True)
  rgbs = [map(int, c.center.coordinates) for c in clusters]
  col_l = list(map(rgb_to_hex, rgbs))
  return col_l


## colors = get_colors('static/images/work-remote.jpg', 8) ## Just to check everything's working fine